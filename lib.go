// Copyright 2025 Colton Loftus
// SPDX-License-Identifier: AGPL-3.0-only

//go:generate go run ./generator
package pkg

import (
	"github.com/godbus/dbus/v5"
)

/* All functions in this file are not autogenerated
they are written by hand since it is easier to manage
or update them this way
*/

// An error representing an error from inside Orca after
// running a command through dbus
type OrcaError struct {
	msg string
}

func NewOrcaError(msg string) *OrcaError {
	return &OrcaError{msg: msg}
}

func (e *OrcaError) Error() string {
	return e.msg
}

func NewOrcaClient() (*OrcaClient, error) {
	conn, err := dbus.ConnectSessionBus()
	if err != nil {
		return nil, err
	}

	manager := SpeechAndVerbosityManager{conn: conn}

	return &OrcaClient{conn: conn, SpeechAndVerbosityManager: manager}, nil
}

func (c *OrcaClient) Close() {
	_ = c.conn.Close()
}

// Present a message to the user user Orca's speech and/or
// braille output
func (c *OrcaClient) PresentMessage(message string) error {
	obj := c.conn.Object(OrcaServiceName, OrcaObjectPath)
	var result bool
	err := obj.Call("org.gnome.Orca.Service.PresentMessage", 0, message).Store(&result)
	if err != nil {
		return err
	}
	if !result {
		// this could be due to voice being disabled in Orca
		return NewOrcaError("message was not presented by Orca")
	}
	return nil
}

func (c *OrcaClient) GetVersion() (string, error) {
	obj := c.conn.Object(OrcaServiceName, OrcaObjectPath)
	var result string
	// Call the DBus method without arguments
	err := obj.Call("org.gnome.Orca.Service.GetVersion", 0).Store(&result)
	if err != nil {
		return "", err
	}
	if result == "" {
		// Handle the case where the version could not be retrieved
		return "", NewOrcaError("version could not be retrieved from Orca")
	}
	return result, nil
}
